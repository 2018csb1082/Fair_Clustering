# -*- coding: utf-8 -*-
"""EquitableGroupRepresentations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qpA6wyyIzmoRQ_U8-z4hM2-lhMRW13-V?usp=sharing
"""

import pandas as pd
import numpy as np
import math
import random
import time
import io
import random
import statistics
from itertools import combinations

# from google.colab import files
# uploaded = files.upload()

n=400
k=2

# creating data to be used
bank=pd.read_csv("D:/personel/codez/btp/trial/bank-original.csv",sep=";")
bank=bank.drop(['y','job','education','month','default','housing','loan','contact','day','pdays','previous','poutcome','campaign'],1) 
bank=bank.drop(bank[bank['marital']=='divorced'].index)
gama=np.array(bank['marital'])
bank=bank.drop('marital',1)
raw_data=np.array(bank[0:n][:])
data = [list(raw_data[i]) for i in range(n)]
avg0 = avg1 = avg2 = 0
for i in range(n):
  avg0 += data[i][0]
  avg1 += data[i][1]
  avg2 += data[i][2]
avg0 = avg0/n
avg1 = avg1/n
avg2 = avg2/n
col0 = [data[i][0] for i in range(n)]
col1 = [data[i][1] for i in range(n)]
col2 = [data[i][2] for i in range(n)]
var0 = math.sqrt(statistics.variance(col0))
var1 = math.sqrt(statistics.variance(col1))
var2 = math.sqrt(statistics.variance(col2))
for i in range(n):
  data[i][0] = (data[i][0]-avg0)/var0
  data[i][1] = (data[i][1]-avg1)/var1
  data[i][2] = (data[i][2]-avg2)/var2
# print(len(data))
# print(data)
col1 = [data[i][0] for i in range(n)]
col2 = [data[i][1] for i in range(n)]
col3 = [data[i][2] for i in range(n)]
print(avg0,avg1,avg2)
print(max(col1),max(col2),max(col3))
print(min(col1),min(col2),min(col3))

# creating data to be used
data_group=[gama[i] for i in range(n)]
i=0
while (i<n):
  if data_group[i] == 'married':
    data_group[i] = 1
  if data_group[i] == 'single':
    data_group[i] = 0
  i += 1

start=time.time() 
print(len(data_group))
print(data_group)

# creating data to be used
distances = np.zeros((n, n))
avg_dist = i = count = 0
while i < n:
  j = 0
  while j < n:
    # distances[i][j] = math.sqrt(((data[i][0]-data[j][0])*(data[i][0]-data[j][0]))+((data[i][1]-data[j][1])*(data[i][1]-data[j][1]))+((data[i][2]-data[j][2])*(data[i][2]-data[j][2])))
    distances[i][j] = abs(((data[i][0]-data[j][0]))+((data[i][1]-data[j][1]))+((data[i][2]-data[j][2])))
    avg_dist += distances[i][j]
    count += 1
    j += 1
  i += 1
avg_dist = avg_dist/count
print(avg_dist)

# creating data to be used # not using anymore -- depricated
# indices = [i for i in range(n)]
# comb = list(combinations(indices, k))
# random.shuffle(comb)
# for i in comb:
#   print(i)

# defining cost function
def cost_function():
  group_cost = [0,0]
  count_g0 = count_g1 = 0
  for i in range(n):
    curr_group = data_group[i]
    curr_center = assignment[i]
    count_g0 = count_g0 + 1 if curr_group == 0 else count_g0
    count_g1 = count_g1 + 1 if curr_group == 1 else count_g1
    group_cost[curr_group] = group_cost[curr_group] + distances[i][curr_center]
  group_cost[0] = group_cost[0]/count_g0 if count_g0 != 0 else math.inf
  group_cost[1] = group_cost[1]/count_g1 if count_g1 != 0 else math.inf
  # print(group_cost)
  return max(group_cost[0],group_cost[1])

starting_centers = []
starting_centers.append(random.randint(0,n-1))
starting_centers.append(random.randint(0,n-2))
if starting_centers[1] > starting_centers[0] - 1:
  starting_centers[1] += 1
print(starting_centers)

chosen_centers = starting_centers
centers = starting_centers
print(centers)
chosen_assignment = [0]*n
assignment = [0]*n
for i in range(n):
  minn = math.inf
  for j in range(k):
    curr_center = centers[j]
    curr_distance = distances[i][curr_center]
    if (curr_distance < minn):
      minn = curr_distance
      assignment[i] = j
chosen_assignment = assignment
print(assignment)

min_cost = cost_function()
print(min_cost)

# OLD METHOD FOR ITERATING OVER CENTERS # not using anymore -- depricated
# alfa = 1
# while alfa<len(comb):
#   centers = comb[alfa]
#   for i in range(n):
#     minn = math.inf
#     for j in range(k):
#       curr_center = centers[j]
#       curr_distance = distances[i][curr_center]
#       if (curr_distance < minn):
#         minn = curr_distance
#         assignment[i] = j
#   curr_cost = cost_function()
#   min_cost = curr_cost if curr_cost<min_cost else min_cost
#   chosen_centers = comb[alfa] if curr_cost<min_cost else chosen_centers
#   chosen_assignment = assignment if curr_cost<min_cost else chosen_assignment
#   if alfa%200 ==0:
#      print("alfa: ",alfa)
#      print("cost: ", min_cost)
#      print("centers: ", comb[alfa])
#   alfa+=1
# print("FINAL:")
# print(min_cost, chosen_centers)
# print(chosen_assignment)

flag = 0
alpha = 0
while (flag != 1):
  alpha += 1
  if alpha%10 == 0:
    print(alpha)
  flag = 1
  # Check if any other point is a better center
  r = list(range(n))
  random.shuffle(r)
  for c in r:
    centers = list(chosen_centers)
    # Try replacing first center
    if (c != centers[0] and c != centers[1]):
      # set new center
      centers[0] = c
      # do new assignment
      for i in range(n):
        minn = math.inf
        for j in range(k):
          curr_center = centers[j]
          curr_distance = distances[i][curr_center]
          if (curr_distance < minn):
            minn = curr_distance
            assignment[i] = j
      # calculate new cost     
      curr_cost = cost_function()
      # change variables if new cost is better
      if curr_cost<min_cost:
        min_cost = curr_cost
        chosen_centers = centers
        chosen_assignment = assignment
        flag = 0
        break
    centers = list(chosen_centers)    
    # Try replacing second center
    if (c != centers[1] and c != centers[0]):
      # set new center
      centers[1] = c
      # do new assignment
      for i in range(n):
        minn = math.inf
        for j in range(k):
          curr_center = centers[j]
          curr_distance = distances[i][curr_center]
          if (curr_distance < minn):
            minn = curr_distance
            assignment[i] = j
      # calculate new cost     
      curr_cost = cost_function()
      # change variables if new cost is better
      if curr_cost<min_cost:
        min_cost = curr_cost
        chosen_centers = centers
        chosen_assignment = assignment
        flag = 0
        break
print("FINAL:")
print(min_cost, chosen_centers)
print(chosen_assignment)

end = time.time()
print("Time taken: ", end-start)

import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

for i in range(n):
  xs = data[i][0]
  ys = data[i][1]
  zs = data[i][2]
  if chosen_centers[0] == i or chosen_centers[1] == i:
    c = 'red'
  else:
    if chosen_assignment[i] == 0:
      if data_group[i] == 0:
        c = 'navy'
      else:
        c = 'violet'
    else:
      if data_group[i] == 0:
        c = 'yellow'
      else:
        c = 'lime'
  ax.scatter(xs, ys, zs, c=c, marker='o')

ax.set_xlabel('Normalized Age')
ax.set_ylabel('Normalized Balance')
ax.set_zlabel('Normalized Duration')

ax.set_title('Best Cluster')
plt.show()